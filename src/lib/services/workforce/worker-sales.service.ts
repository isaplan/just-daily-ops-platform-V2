/**
 * Worker Sales Service Layer
 * Service functions to calculate sales generated by a worker
 * Checks aggregated collection first, falls back to on-demand calculation
 */

import { getDailySales, SalesFilters } from '@/lib/services/graphql/queries';
import { getDatabase } from '@/lib/mongodb/v2-connection';

export interface WorkerSalesSummary {
  totalRevenue: number;
  totalTransactions: number;
  averageTicketValue: number;
  totalItems: number;
}

/**
 * Get period type from date range
 */
function getPeriodType(startDate: string, endDate: string): 'thisMonth' | 'lastMonth' | 'total' | null {
  const now = new Date();
  const start = new Date(startDate);
  const end = new Date(endDate);
  
  const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
  const thisMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
  if (start.getTime() === thisMonthStart.getTime() && end.getTime() === thisMonthEnd.getTime()) {
    return 'thisMonth';
  }
  
  const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
  const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
  if (start.getTime() === lastMonthStart.getTime() && end.getTime() === lastMonthEnd.getTime()) {
    return 'lastMonth';
  }
  
  const totalStart = new Date(2000, 0, 1);
  if (start.getTime() <= totalStart.getTime() && end >= now) {
    return 'total';
  }
  
  return null;
}

/**
 * Calculate sales generated by a worker
 * Checks aggregated collection first for common periods, calculates on-demand for custom periods
 * @param workerName - Worker's name (matches waiter_name in sales records)
 * @param startDate - Start date (YYYY-MM-DD)
 * @param endDate - End date (YYYY-MM-DD)
 * @returns Sales summary
 */
export async function fetchWorkerSales(
  workerName: string,
  startDate: string,
  endDate: string
): Promise<WorkerSalesSummary> {
  console.log(`[Worker Sales Service] Fetching sales for worker ${workerName}`, { startDate, endDate });
  
  // Check if this is a common period
  const periodType = getPeriodType(startDate, endDate);
  
  if (periodType) {
    // Try aggregated collection first (need to find by userName)
    try {
      const db = await getDatabase();
      const aggregated = await db.collection('worker_profiles_aggregated').findOne({
        userName: workerName
      });
      
      if (aggregated && aggregated[periodType]?.salesSummary) {
        console.log(`[Worker Sales Service] âœ… Found pre-computed sales summary for ${periodType}`);
        return aggregated[periodType].salesSummary;
      }
    } catch (error) {
      console.warn('[Worker Sales Service] Error checking aggregated collection, falling back to calculation:', error);
    }
  }
  
  // Fallback to on-demand calculation
  console.log(`[Worker Sales Service] Calculating sales summary on-demand`);
  
  const summary: WorkerSalesSummary = {
    totalRevenue: 0,
    totalTransactions: 0,
    averageTicketValue: 0,
    totalItems: 0,
  };

  try {
    // Fetch all sales records for this worker
    const filters: SalesFilters = {
      waiterName: workerName,
    };

    // Fetch all pages to get complete data
    let page = 1;
    let hasMore = true;
    const allRecords: any[] = [];
    const uniqueTickets = new Set<string>();

    while (hasMore) {
      const result = await getDailySales(
        startDate,
        endDate,
        page,
        100, // Fetch 100 records per page
        filters
      );

      if (result.success && result.records) {
        allRecords.push(...result.records);
        
        // Track unique transactions (ticket_key)
        result.records.forEach((record) => {
          if (record.ticket_key) {
            uniqueTickets.add(record.ticket_key);
          }
        });

        // Check if there are more pages
        hasMore = page < (result.totalPages || 1);
        page++;
      } else {
        hasMore = false;
      }
    }

    // Calculate totals
    summary.totalRevenue = allRecords.reduce((sum, record) => {
      const revenue = record.total_inc_vat 
        ? Number(record.total_inc_vat) 
        : (record.unit_price && record.quantity 
          ? Number(record.unit_price) * Number(record.quantity) 
          : 0);
      return sum + revenue;
    }, 0);

    summary.totalItems = allRecords.reduce((sum, record) => {
      return sum + Math.abs(Number(record.quantity) || 0);
    }, 0);

    summary.totalTransactions = uniqueTickets.size;
    summary.averageTicketValue = summary.totalTransactions > 0
      ? summary.totalRevenue / summary.totalTransactions
      : 0;
  } catch (error) {
    console.error('[Worker Sales Service] Error fetching sales:', error);
  }

  return summary;
}


