---
alwaysApply: true
---

# ğŸ“‹ DEVELOPMENT STANDARDS

## âš›ï¸ REACT
âœ… **DO:**
- PascalCase file naming (`UserProfile.tsx`)
- TypeScript interfaces for all props
- Hooks at top level of components
- Import order: React â†’ External â†’ Internal â†’ Assets
- Named exports for components, default exports for pages

âŒ **NEVER:**
- Class components (functional only)

---

## ğŸ¨ TAILWIND CSS
âœ… **DO:**
- Use utility classes directly in JSX
- Use `cva` (Class Variance Authority) for component variants
- Use theme values from `tailwind.config.ts` only

âŒ **NEVER:**
- `@apply` in global CSS
- Inline styles (use Tailwind utilities instead)
- Arbitrary values (use theme values)

---

## âš¡ NEXT.JS
âœ… **DO:**
- Add `'use client'` directive for client components
- Use Server Components for data fetching (default)
- Use Client Components for interactivity only
- Use Server Actions for mutations
- Follow App Router conventions (`app/` directory)
- Proper import order and organization

---

## ğŸ—ï¸ MVVM PATTERN (MODEL-VIEW-VIEWMODEL)
âœ… **DO:**
- **Model**: Data structures, business logic, and state management
  - Keep models pure and framework-agnostic
  - Use TypeScript interfaces/types for data contracts
  - Separate data fetching logic from presentation
- **View**: React components (presentation layer only)
  - Keep components focused on rendering UI
  - Use Server Components for data fetching when possible
  - Use Client Components only for interactivity
- **ViewModel**: Bridge between Model and View
  - Handle data transformation and formatting
  - Manage component state and user interactions
  - Use custom hooks for reusable ViewModel logic
  - Implement business rules and validation in ViewModel

**Pattern Structure:**
```
src/
  models/          # Data structures, types, business logic
  views/           # React components (presentation)
  viewmodels/      # Custom hooks, state management, data transformation
  services/        # API calls, external integrations
```

**Benefits:**
- âœ… Clear separation of concerns (best of CHAT/Claude and Composer)
- âœ… Testable business logic (independent of UI)
- âœ… Reusable ViewModels across different Views
- âœ… Easier to maintain and refactor
- âœ… Better collaboration (frontend/backend separation)

âŒ **NEVER:**
- Mix business logic directly in View components
- Put data fetching logic in View components (use ViewModel hooks)
- Create tight coupling between Model and View

---

## ğŸš€ MVVM + SSR HYBRID PATTERN (CRITICAL - PERFORMANCE)

### **Pattern: Server Component Wrapper + Client Component UI**

**For data-heavy pages, use this 2-file pattern:**

#### **File 1: `page.tsx` - Server Component (NO "use client")**
```typescript
// src/app/(dashboard)/finance/page.tsx
// âœ… NO "use client" directive - This is a Server Component

import { FinancePageClient } from './FinancePageClient';
import { fetchFinanceData } from '@/lib/services/finance/finance.service';

// âœ… Add ISR revalidation
export const revalidate = 1800; // 30 minutes

export default async function FinancePage() {
  // âœ… Fetch data on server (fast, SSR)
  const initialData = await fetchFinanceData();
  
  // âœ… Pass server data to client component
  return <FinancePageClient initialData={initialData} />;
}
```

#### **File 2: `FinancePageClient.tsx` - Client Component**
```typescript
// src/app/(dashboard)/finance/FinancePageClient.tsx
'use client';

import { useFinanceViewModel } from '@/viewmodels/finance/useFinanceViewModel';

export function FinancePageClient({ initialData }) {
  // âœ… ViewModel uses server data as initial, updates client-side
  const { data, isLoading, error } = useFinanceViewModel(initialData);
  
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Finance Dashboard</h1>
      {/* Interactive UI here */}
    </div>
  );
}
```

### **When to Use Which Pattern:**

| Page Type | Pattern | Reason |
|-----------|---------|--------|
| **Data-heavy dashboards** | Server Component wrapper + Client UI | Fast initial load, SEO, cacheable |
| **Highly interactive forms** | Client Component only | Needs lots of state management |
| **Static content** | Server Component only | No interactivity needed |

### **ViewModel Adaptation for SSR:**

ViewModels should accept `initialData` to support SSR:

```typescript
// src/viewmodels/finance/useFinanceViewModel.ts
export function useFinanceViewModel(initialData?: FinanceData) {
  const { data, isLoading } = useQuery({
    queryKey: ['finance-data'],
    queryFn: fetchFinanceData,
    initialData, // âœ… Use server data if provided
    staleTime: 30 * 60 * 1000, // 30 minutes
  });
  
  return { data, isLoading, /* ... */ };
}
```

### **Benefits:**
- âš¡ **80-90% faster initial page load**
- ğŸ“¦ **CDN cacheable** - Pages can be cached at edge
- ğŸ” **SEO-friendly** - Fully rendered HTML
- ğŸ’¾ **Reduced database load** - ISR caching
- ğŸ¯ **Still interactive** - Client Component handles UI

### **Rules:**
- âœ… **ALWAYS** use Server Component wrapper for dashboard pages
- âœ… **ALWAYS** add `export const revalidate = 1800` for ISR
- âœ… **ALWAYS** pass `initialData` to ViewModels
- âŒ **NEVER** use `'use client'` on main `page.tsx` for data-heavy pages

---

## ğŸ¨ SHADCN/UI (CRITICAL - UI CONSISTENCY)
âœ… **DO:**
- **ALWAYS** use shadcn/ui components when available
- Import from `@/components/ui/[component]`
- Use proper shadcn component names and props
- Follow shadcn component patterns and structure

âŒ **NEVER:**
- Create custom implementations of shadcn components
- Reinvent shadcn functionality
- Use custom styling when shadcn provides the component

---

**Violation of these standards = compliance issue**
