---
alwaysApply: true
---

# üìä AGGREGATED DATABASE WORKFLOW (CRITICAL)

## üéØ WORKFLOW PRINCIPLE

**ALWAYS use aggregated collections for GraphQL queries. Raw data is ONLY for cron jobs.**

### **Data Flow:**
```
Raw Data (cron) ‚Üí Aggregated Database (daily cron) ‚Üí GraphQL Queries ‚Üí UI
```

---

## üéØ AGGREGATED COLLECTION PRINCIPLE (CRITICAL)

**Aggregated collections must contain ALL data pre-computed. GraphQL resolvers should NEVER query other collections for enrichment.**

### **What "Aggregated" Means:**

- ‚úÖ **ALL data is pre-fetched and stored** - field:value pairs, no thinking, no querying other databases
- ‚úÖ **Zero additional queries** - GraphQL resolver reads from aggregated collection and returns directly
- ‚úÖ **Denormalized data** - Store names, IDs, and all related data together (e.g., `locationName` + `locationId`, `userName` + `eitjeUserId`)
- ‚úÖ **Pre-computed relationships** - All connected data should be calculated during aggregation, not at query time

### **‚ùå FORBIDDEN in GraphQL Resolvers:**

```typescript
// ‚ùå WRONG: Enrichment queries in GraphQL resolver
const records = await db.collection('worker_profiles_aggregated').find(query).toArray();
const enrichedRecords = await enrichWithLocationNames(records); // NO!
const enrichedRecords = await enrichWithUserNames(enrichedRecords); // NO!
```

### **‚úÖ CORRECT Pattern:**

```typescript
// ‚úÖ CORRECT: Aggregated collection has all data pre-computed
const records = await db.collection('worker_profiles_aggregated').find(query).toArray();
// Records already contain: locationName, userName, locationNames, etc.
// Just return directly - no enrichment needed
return records.map(transformToGraphQLFormat);
```

### **Aggregation Service Responsibility:**

**During aggregation, the service MUST:**

1. **Denormalize location data:**
   - Query `locations` collection ONCE during aggregation
   - Store `locationName` (not just `locationId`)
   - Store `locationNames[]` (not just `locationIds[]`)

2. **Denormalize user data:**
   - Query `unified_users` collection ONCE during aggregation
   - Store `userName` (not just `eitjeUserId`)
   - Store all needed user fields

3. **Pre-compute relationships:**
   - Calculate all connected data (hours, sales, labor cost) during aggregation
   - Store in aggregated collection (e.g., `thisMonth`, `lastMonth`, `total` periods)

4. **Store IDs for fallback only:**
   - Keep `locationId`, `eitjeUserId` for reference/fallback
   - But primary data should be names/values, not IDs

### **GraphQL Resolver Responsibility:**

**GraphQL resolvers MUST:**

1. **Query aggregated collection only:**
   ```typescript
   const records = await db.collection('worker_profiles_aggregated').find(query).toArray();
   ```

2. **Return data directly:**
   ```typescript
   return records.map(transformToGraphQLFormat);
   ```

3. **NO enrichment queries:**
   - ‚ùå Never call `enrichWithLocationNames()`
   - ‚ùå Never call `enrichWithUserNames()`
   - ‚ùå Never query `locations` collection
   - ‚ùå Never query `unified_users` collection

4. **Fallback pattern (only for backward compatibility):**
   ```typescript
   // Only enrich if data is missing (fallback to old collection)
   if (!record.locationName || !record.userName) {
     // This is from fallback worker_profiles collection (not aggregated)
     enrichedRecords = await enrichWithLocationNames(records);
     enrichedRecords = await enrichWithUserNames(enrichedRecords);
   }
   ```

### **Example: products_aggregated (CORRECT Pattern):**

**Schema:**
```typescript
export interface ProductsAggregated {
  productName: string;
  locationId?: ObjectId; // For reference/fallback
  locationName?: string; // ‚úÖ Pre-computed during aggregation
  locationDetails?: Array<{
    locationId: ObjectId;
    locationName: string; // ‚úÖ Pre-computed
    totalQuantitySold: number;
    totalRevenue: number;
  }>;
  // ... all other fields pre-computed
}
```

**GraphQL Resolver:**
```typescript
// ‚úÖ CORRECT: Just read and return
const product = await db.collection('products_aggregated').findOne(query);
return {
  id: product._id.toString(),
  productName: product.productName,
  locationName: product.locationName, // Already there!
  // ... no enrichment queries
};
```

### **Example: worker_profiles_aggregated (TO FIX):**

**Current (WRONG):**
```typescript
// ‚ùå WRONG: Enrichment in resolver
const records = await db.collection('worker_profiles_aggregated').find(query).toArray();
let enrichedRecords = await enrichWithLocationNames(records); // NO!
enrichedRecords = await enrichWithUserNames(enrichedRecords); // NO!
```

**Should Be (CORRECT):**
```typescript
// ‚úÖ CORRECT: All data pre-computed
const records = await db.collection('worker_profiles_aggregated').find(query).toArray();
// Records already have: locationName, userName, locationNames, etc.
return records.map(transformToGraphQLFormat);
```

### **Verification Checklist:**

When creating/updating aggregated collections:

- [ ] Aggregation service queries `locations` collection and stores `locationName`
- [ ] Aggregation service queries `unified_users` collection and stores `userName`
- [ ] All related data is pre-computed and stored (not calculated at query time)
- [ ] GraphQL resolver reads from aggregated collection only
- [ ] GraphQL resolver returns data directly (no enrichment functions)
- [ ] No `enrichWithLocationNames()` calls in resolvers
- [ ] No `enrichWithUserNames()` calls in resolvers
- [ ] No queries to `locations` collection in resolvers
- [ ] No queries to `unified_users` collection in resolvers

---

## ‚úÖ AGGREGATED COLLECTIONS (USE THESE)

### **Products:**
- ‚úÖ **`products_aggregated`** - Single source of truth for all product data
  - Contains: sales stats, price history, location details, menu associations, categories, workload/MEP metrics
  - Updated by: `/api/products/aggregate` (daily cron)
  - GraphQL: `products`, `product`, `productByName`, `categoriesProductsAggregate`
  - **Status:** ‚úÖ Migrated - All product queries/mutations use this

### **Sales:**
- ‚úÖ **`bork_aggregated`** - Daily sales aggregations
  - Contains: daily totals per location, revenue by category
  - Updated by: Bork sync cron jobs
  - GraphQL: `salesAggregated`
  - **Status:** ‚úÖ Migrated - Used for dashboard queries

### **Labor:**
- ‚úÖ **`eitje_aggregated`** - Daily labor aggregations
  - Contains: daily hours, wage costs, team stats
  - Updated by: Eitje sync cron jobs
  - GraphQL: `laborAggregated`
  - **Status:** ‚úÖ Migrated - Used for dashboard queries

---

## ‚ùå RAW DATA COLLECTIONS (DON'T USE IN GRAPHQL)

### **When to use raw data:**
- ‚úÖ **ONLY in cron jobs** that populate aggregated collections
- ‚úÖ **ONLY for diagnostics/debugging** (e.g., `checkTeamData` resolver)
- ‚úÖ **ONLY when transaction-level detail is required** (document exception)

### **When NOT to use raw data:**
- ‚ùå **NEVER in GraphQL resolvers** (too slow, causes timeouts)
- ‚ùå **NEVER in API routes** that serve UI data
- ‚ùå **NEVER in ViewModels or Services** that fetch data for pages

---

## üîß MIGRATION CHECKLIST

When building a new feature or fixing existing code:

1. **Check if aggregated collection exists:**
   - ‚úÖ If yes ‚Üí Use aggregated collection in GraphQL resolver
   - ‚ùå If no ‚Üí Create aggregated collection + daily cron job first

2. **Update GraphQL resolvers:**
   - Replace `collection('products')` ‚Üí `collection('products_aggregated')`
   - Replace `collection('bork_raw_data')` ‚Üí `collection('bork_aggregated')` (if applicable)
   - Replace `collection('eitje_raw_data')` ‚Üí `collection('eitje_aggregated')` (if applicable)

3. **Create/Update daily cron job:**
   - Aggregates raw data ‚Üí aggregated collection
   - **Denormalizes data** (queries `locations` and `unified_users` ONCE, stores names)
   - Stores `locationName` (not just `locationId`)
   - Stores `userName` (not just `eitjeUserId`)
   - Pre-computes all relationships and connected data
   - Runs daily (or on-demand via API route)
   - Preserves existing data (merge, don't overwrite)

4. **Verify:**
   - GraphQL queries use aggregated collections
   - No raw_data queries in resolvers (except diagnostics)
   - No enrichment queries in resolvers (`enrichWithLocationNames`, `enrichWithUserNames`)
   - Aggregated collection contains all needed data (names, not just IDs)
   - Cron job updates aggregated collection correctly

---

## üö® COMMON MISTAKES

### ‚ùå **WRONG:**
```typescript
// GraphQL resolver querying raw data
const products = await db.collection('bork_raw_data')
  .find({ productName: 'Pizza' })
  .toArray();
```

### ‚úÖ **CORRECT:**
```typescript
// GraphQL resolver querying aggregated data
const products = await db.collection('products_aggregated')
  .find({ productName: 'Pizza' })
  .toArray();
```

---

## üìã CURRENT STATUS

### ‚úÖ **Migrated to Aggregated:**
- `categoriesProductsAggregate` ‚Üí uses `products_aggregated`
- `salesAggregated` ‚Üí uses `bork_aggregated`
- `laborAggregated` ‚Üí uses `eitje_aggregated`

### ‚ö†Ô∏è **Exceptions (Documented):**
- `dailySales` resolver ‚Üí uses `bork_raw_data` (needs transaction-level detail: ticket keys, order keys, waiter names, table numbers, payment methods, timestamps)
- `extractSalesRecords` helper ‚Üí uses `bork_raw_data` (used by resolvers needing transaction detail)
- `checkTeamData` resolver ‚Üí uses `eitje_raw_data` (diagnostics only)

**Why exceptions exist:**
- Aggregated collections store daily/product totals, not individual transaction line items
- Some views require transaction-level detail (e.g., detailed sales reports with waiter/table info)
- These resolvers are documented with comments explaining why raw data is necessary

### ‚ùå **Still Using Raw/Old Collections (TO FIX):**
- None - all product queries/mutations migrated to `products_aggregated`

---

## üîç VERIFICATION COMMANDS

To check for violations:

```bash
# Find GraphQL resolvers using raw data (should be empty except exceptions)
grep -r "collection('bork_raw_data')" src/lib/graphql/
grep -r "collection('eitje_raw_data')" src/lib/graphql/

# Find old product collection usage (should be empty)
grep -r "collection('products')" src/lib/graphql/v2-resolvers.ts

# Find enrichment functions in resolvers (should be empty or only in fallback code)
grep -r "enrichWithLocationNames" src/lib/graphql/
grep -r "enrichWithUserNames" src/lib/graphql/

# Find queries to locations/unified_users in resolvers (should be empty)
grep -r "collection('locations')" src/lib/graphql/
grep -r "collection('unified_users')" src/lib/graphql/
```

---

## üìä HIERARCHICAL TIME-SERIES DATA (NEW)

### **Structure:**

Both `products_aggregated` and `eitje_aggregated` now support hierarchical time-series data for fast historical queries:

**Products:**
- `salesByYear` - Year totals with location breakdowns
- `salesByMonth` - Month totals (only months >1 month old)
- `salesByWeek` - Week totals (only weeks >1 week old)
- `salesByDay` - Day totals (only current week, excluding today)

**Labor:**
- `hoursByYear` - Year totals with location ‚Üí team ‚Üí worker breakdowns
- `hoursByMonth` - Month totals (only months >1 month old)
- `hoursByWeek` - Week totals (only weeks >1 week old)
- `hoursByDay` - Day totals (only current week, excluding today)

### **When to Use Hierarchical Data:**

- ‚úÖ **ALWAYS check for hierarchical data first** in GraphQL resolvers
- ‚úÖ **Route based on query type** (year/month/week/day) using `detectQueryType()`
- ‚úÖ **Use hierarchical data** when available for 10-100x faster queries
- ‚úÖ **Fallback to calculation** if hierarchical data missing (backward compatibility)

### **GraphQL Resolver Routing Logic:**

**Decision Tree:**
1. Check if hierarchical data exists (`hasHierarchicalData()`)
2. If yes, detect query type (`detectQueryType(startDate, endDate)`)
3. Route to appropriate hierarchical field:
   - Year query ‚Üí `salesByYear` / `hoursByYear`
   - Month query ‚Üí `salesByMonth` / `hoursByMonth`
   - Week query ‚Üí `salesByWeek` / `hoursByWeek`
   - Day query ‚Üí `salesByDay` / `hoursByDay`
4. Apply location/team/worker filters within hierarchical data
5. If no hierarchical data, fallback to existing calculation logic

**Example (Products):**
```typescript
// ‚úÖ CORRECT: Use hierarchical data for year queries
const yearData = product.salesByYear?.find(y => y.year === "2025");
if (yearData) {
  let locationData = yearData.byLocation;
  if (locationId) {
    locationData = locationData.filter(loc => loc.locationId.toString() === locationId);
  }
  return {
    total: {
      quantity: locationData.reduce((sum, loc) => sum + loc.quantity, 0),
      revenueExVat: locationData.reduce((sum, loc) => sum + loc.revenueExVat, 0),
      // ...
    }
  };
}

// ‚úÖ CORRECT: Fallback to calculation if hierarchical data missing
if (!product.salesByYear || product.salesByYear.length === 0) {
  // Calculate from salesByDate (backward compatibility)
  return calculateYearTotals(product.salesByDate, locationId);
}
```

**Example (Labor):**
```typescript
// ‚úÖ CORRECT: Use hierarchical data for year queries with worker breakdown
const yearData = record.hoursByYear?.find(y => y.year === "2025");
if (yearData) {
  const locationData = yearData.byLocation.find(loc => 
    loc.locationId.toString() === locationId
  );
  if (locationData) {
    // Filter by team if specified
    let teams = locationData.byTeam;
    if (teamId) {
      teams = teams.filter(team => team.teamId === teamId);
    }
    // Filter by worker if specified
    if (workerId) {
      teams = teams.map(team => ({
        ...team,
        byWorker: team.byWorker.filter(w => w.unifiedUserId.toString() === workerId)
      }));
    }
    return teams;
  }
}
```

### **Reaggregation Requirements:**

**When hierarchical data is missing:**
- Run `/api/products/reaggregate-hierarchical` to populate products
- Run `/api/eitje/v2/reaggregate-hierarchical` to populate labor records
- These endpoints process all historical data and build hierarchical structure

**Incremental Updates:**
- Daily aggregation cron jobs automatically update hierarchical data
- New days/weeks/months are added as time passes
- Data moves between levels (week ‚Üí month when week is >1 week old)

### **Migration Checklist (Updated):**

When building a new feature or fixing existing code:

1. **Check if aggregated collection exists:**
   - ‚úÖ If yes ‚Üí Use aggregated collection in GraphQL resolver
   - ‚ùå If no ‚Üí Create aggregated collection + daily cron job first

2. **Update GraphQL resolvers:**
   - Replace `collection('products')` ‚Üí `collection('products_aggregated')`
   - Replace `collection('bork_raw_data')` ‚Üí `collection('bork_aggregated')` (if applicable)
   - Replace `collection('eitje_raw_data')` ‚Üí `collection('eitje_aggregated')` (if applicable)
   - **NEW:** Check for hierarchical data first, route based on query type
   - **NEW:** Fallback to calculation if hierarchical data missing

3. **Create/Update daily cron job:**
   - Aggregates raw data ‚Üí aggregated collection
   - **Denormalizes data** (queries `locations` and `unified_users` ONCE, stores names)
   - Stores `locationName` (not just `locationId`)
   - Stores `userName` (not just `eitjeUserId`)
   - **NEW:** Builds hierarchical time-series structure
   - Pre-computes all relationships and connected data
   - Runs daily (or on-demand via API route)
   - Preserves existing data (merge, don't overwrite)

4. **Reaggregate existing data:**
   - Run `/api/products/reaggregate-hierarchical` for products
   - Run `/api/eitje/v2/reaggregate-hierarchical` for labor
   - This populates hierarchical data for all existing records

5. **Verify:**
   - GraphQL queries use hierarchical data when available
   - Resolvers fallback to calculation if hierarchical data missing
   - No raw_data queries in resolvers (except diagnostics)
   - No enrichment queries in resolvers (`enrichWithLocationNames`, `enrichWithUserNames`)
   - Aggregated collection contains all needed data (names, not just IDs)
   - Cron job updates hierarchical data correctly

---

**Priority:** üî¥ HIGHEST - This rule prevents 404/500 errors and performance issues
