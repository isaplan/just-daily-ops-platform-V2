---
alwaysApply: true
---

# üìä AGGREGATED DATABASE WORKFLOW (CRITICAL)

## üéØ WORKFLOW PRINCIPLE

**ALWAYS use aggregated collections for GraphQL queries. Raw data is ONLY for cron jobs.**

### **Data Flow:**
```
Raw Data (cron) ‚Üí Aggregated Database (daily cron) ‚Üí GraphQL Queries ‚Üí UI
```

---

## ‚úÖ AGGREGATED COLLECTIONS (USE THESE)

### **Products:**
- ‚úÖ **`products_aggregated`** - Single source of truth for all product data
  - Contains: sales stats, price history, location details, menu associations, categories, workload/MEP metrics
  - Updated by: `/api/products/aggregate` (daily cron)
  - GraphQL: `products`, `product`, `productByName`, `categoriesProductsAggregate`
  - **Status:** ‚úÖ Migrated - All product queries/mutations use this

### **Sales:**
- ‚úÖ **`bork_aggregated`** - Daily sales aggregations
  - Contains: daily totals per location, revenue by category
  - Updated by: Bork sync cron jobs
  - GraphQL: `salesAggregated`
  - **Status:** ‚úÖ Migrated - Used for dashboard queries

### **Labor:**
- ‚úÖ **`eitje_aggregated`** - Daily labor aggregations
  - Contains: daily hours, wage costs, team stats
  - Updated by: Eitje sync cron jobs
  - GraphQL: `laborAggregated`
  - **Status:** ‚úÖ Migrated - Used for dashboard queries

---

## ‚ùå RAW DATA COLLECTIONS (DON'T USE IN GRAPHQL)

### **When to use raw data:**
- ‚úÖ **ONLY in cron jobs** that populate aggregated collections
- ‚úÖ **ONLY for diagnostics/debugging** (e.g., `checkTeamData` resolver)
- ‚úÖ **ONLY when transaction-level detail is required** (document exception)

### **When NOT to use raw data:**
- ‚ùå **NEVER in GraphQL resolvers** (too slow, causes timeouts)
- ‚ùå **NEVER in API routes** that serve UI data
- ‚ùå **NEVER in ViewModels or Services** that fetch data for pages

---

## üîß MIGRATION CHECKLIST

When building a new feature or fixing existing code:

1. **Check if aggregated collection exists:**
   - ‚úÖ If yes ‚Üí Use aggregated collection in GraphQL resolver
   - ‚ùå If no ‚Üí Create aggregated collection + daily cron job first

2. **Update GraphQL resolvers:**
   - Replace `collection('products')` ‚Üí `collection('products_aggregated')`
   - Replace `collection('bork_raw_data')` ‚Üí `collection('bork_aggregated')` (if applicable)
   - Replace `collection('eitje_raw_data')` ‚Üí `collection('eitje_aggregated')` (if applicable)

3. **Create/Update daily cron job:**
   - Aggregates raw data ‚Üí aggregated collection
   - Runs daily (or on-demand via API route)
   - Preserves existing data (merge, don't overwrite)

4. **Verify:**
   - GraphQL queries use aggregated collections
   - No raw_data queries in resolvers (except diagnostics)
   - Cron job updates aggregated collection correctly

---

## üö® COMMON MISTAKES

### ‚ùå **WRONG:**
```typescript
// GraphQL resolver querying raw data
const products = await db.collection('bork_raw_data')
  .find({ productName: 'Pizza' })
  .toArray();
```

### ‚úÖ **CORRECT:**
```typescript
// GraphQL resolver querying aggregated data
const products = await db.collection('products_aggregated')
  .find({ productName: 'Pizza' })
  .toArray();
```

---

## üìã CURRENT STATUS

### ‚úÖ **Migrated to Aggregated:**
- `categoriesProductsAggregate` ‚Üí uses `products_aggregated`
- `salesAggregated` ‚Üí uses `bork_aggregated`
- `laborAggregated` ‚Üí uses `eitje_aggregated`

### ‚ö†Ô∏è **Exceptions (Documented):**
- `dailySales` resolver ‚Üí uses `bork_raw_data` (needs transaction-level detail: ticket keys, order keys, waiter names, table numbers, payment methods, timestamps)
- `extractSalesRecords` helper ‚Üí uses `bork_raw_data` (used by resolvers needing transaction detail)
- `checkTeamData` resolver ‚Üí uses `eitje_raw_data` (diagnostics only)

**Why exceptions exist:**
- Aggregated collections store daily/product totals, not individual transaction line items
- Some views require transaction-level detail (e.g., detailed sales reports with waiter/table info)
- These resolvers are documented with comments explaining why raw data is necessary

### ‚ùå **Still Using Raw/Old Collections (TO FIX):**
- None - all product queries/mutations migrated to `products_aggregated`

---

## üîç VERIFICATION COMMANDS

To check for violations:

```bash
# Find GraphQL resolvers using raw data (should be empty except exceptions)
grep -r "collection('bork_raw_data')" src/lib/graphql/
grep -r "collection('eitje_raw_data')" src/lib/graphql/

# Find old product collection usage (should be empty)
grep -r "collection('products')" src/lib/graphql/v2-resolvers.ts
```

---

## üìä HIERARCHICAL TIME-SERIES DATA (NEW)

### **Structure:**

Both `products_aggregated` and `eitje_aggregated` now support hierarchical time-series data for fast historical queries:

**Products:**
- `salesByYear` - Year totals with location breakdowns
- `salesByMonth` - Month totals (only months >1 month old)
- `salesByWeek` - Week totals (only weeks >1 week old)
- `salesByDay` - Day totals (only current week, excluding today)

**Labor:**
- `hoursByYear` - Year totals with location ‚Üí team ‚Üí worker breakdowns
- `hoursByMonth` - Month totals (only months >1 month old)
- `hoursByWeek` - Week totals (only weeks >1 week old)
- `hoursByDay` - Day totals (only current week, excluding today)

### **When to Use Hierarchical Data:**

- ‚úÖ **ALWAYS check for hierarchical data first** in GraphQL resolvers
- ‚úÖ **Route based on query type** (year/month/week/day) using `detectQueryType()`
- ‚úÖ **Use hierarchical data** when available for 10-100x faster queries
- ‚úÖ **Fallback to calculation** if hierarchical data missing (backward compatibility)

### **GraphQL Resolver Routing Logic:**

**Decision Tree:**
1. Check if hierarchical data exists (`hasHierarchicalData()`)
2. If yes, detect query type (`detectQueryType(startDate, endDate)`)
3. Route to appropriate hierarchical field:
   - Year query ‚Üí `salesByYear` / `hoursByYear`
   - Month query ‚Üí `salesByMonth` / `hoursByMonth`
   - Week query ‚Üí `salesByWeek` / `hoursByWeek`
   - Day query ‚Üí `salesByDay` / `hoursByDay`
4. Apply location/team/worker filters within hierarchical data
5. If no hierarchical data, fallback to existing calculation logic

**Example (Products):**
```typescript
// ‚úÖ CORRECT: Use hierarchical data for year queries
const yearData = product.salesByYear?.find(y => y.year === "2025");
if (yearData) {
  let locationData = yearData.byLocation;
  if (locationId) {
    locationData = locationData.filter(loc => loc.locationId.toString() === locationId);
  }
  return {
    total: {
      quantity: locationData.reduce((sum, loc) => sum + loc.quantity, 0),
      revenueExVat: locationData.reduce((sum, loc) => sum + loc.revenueExVat, 0),
      // ...
    }
  };
}

// ‚úÖ CORRECT: Fallback to calculation if hierarchical data missing
if (!product.salesByYear || product.salesByYear.length === 0) {
  // Calculate from salesByDate (backward compatibility)
  return calculateYearTotals(product.salesByDate, locationId);
}
```

**Example (Labor):**
```typescript
// ‚úÖ CORRECT: Use hierarchical data for year queries with worker breakdown
const yearData = record.hoursByYear?.find(y => y.year === "2025");
if (yearData) {
  const locationData = yearData.byLocation.find(loc => 
    loc.locationId.toString() === locationId
  );
  if (locationData) {
    // Filter by team if specified
    let teams = locationData.byTeam;
    if (teamId) {
      teams = teams.filter(team => team.teamId === teamId);
    }
    // Filter by worker if specified
    if (workerId) {
      teams = teams.map(team => ({
        ...team,
        byWorker: team.byWorker.filter(w => w.unifiedUserId.toString() === workerId)
      }));
    }
    return teams;
  }
}
```

### **Reaggregation Requirements:**

**When hierarchical data is missing:**
- Run `/api/products/reaggregate-hierarchical` to populate products
- Run `/api/eitje/v2/reaggregate-hierarchical` to populate labor records
- These endpoints process all historical data and build hierarchical structure

**Incremental Updates:**
- Daily aggregation cron jobs automatically update hierarchical data
- New days/weeks/months are added as time passes
- Data moves between levels (week ‚Üí month when week is >1 week old)

### **Migration Checklist (Updated):**

When building a new feature or fixing existing code:

1. **Check if aggregated collection exists:**
   - ‚úÖ If yes ‚Üí Use aggregated collection in GraphQL resolver
   - ‚ùå If no ‚Üí Create aggregated collection + daily cron job first

2. **Update GraphQL resolvers:**
   - Replace `collection('products')` ‚Üí `collection('products_aggregated')`
   - Replace `collection('bork_raw_data')` ‚Üí `collection('bork_aggregated')` (if applicable)
   - Replace `collection('eitje_raw_data')` ‚Üí `collection('eitje_aggregated')` (if applicable)
   - **NEW:** Check for hierarchical data first, route based on query type
   - **NEW:** Fallback to calculation if hierarchical data missing

3. **Create/Update daily cron job:**
   - Aggregates raw data ‚Üí aggregated collection
   - **NEW:** Builds hierarchical time-series structure
   - Runs daily (or on-demand via API route)
   - Preserves existing data (merge, don't overwrite)

4. **Reaggregate existing data:**
   - Run `/api/products/reaggregate-hierarchical` for products
   - Run `/api/eitje/v2/reaggregate-hierarchical` for labor
   - This populates hierarchical data for all existing records

5. **Verify:**
   - GraphQL queries use hierarchical data when available
   - Resolvers fallback to calculation if hierarchical data missing
   - No raw_data queries in resolvers (except diagnostics)
   - Cron job updates hierarchical data correctly

---

**Priority:** üî¥ HIGHEST - This rule prevents 404/500 errors and performance issues
