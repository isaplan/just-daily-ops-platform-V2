---
alwaysApply: true
---

# üöÄ PERFORMANCE & SSR OPTIMIZATION

## üìä DATABASE PAGINATION (MANDATORY)

**NEVER fetch all data from database:**

```typescript
// ‚ùå WRONG - Fetches all records (100k+)
const data = await db.collection('records').find({}).toArray();

// ‚úÖ CORRECT - Paginate at database level
const data = await db.collection('records')
  .find({})
  .skip((page - 1) * limit)
  .limit(limit)
  .toArray();
```

**ALL GraphQL list resolvers MUST support pagination:**

```typescript
salesAggregated: async (
  _: any,
  { page = 1, limit = 50 }: { page?: number; limit?: number }
) => {
  const db = await getDatabase();
  const skip = (page - 1) * limit;
  
  // ‚úÖ Parallel queries for performance
  const [records, total] = await Promise.all([
    db.collection('bork_aggregated')
      .find({})
      .sort({ date: -1 })
      .skip(skip)
      .limit(limit)
      .toArray(),
    db.collection('bork_aggregated').countDocuments({}),
  ]);
  
  return {
    records,
    total,
    page,
    totalPages: Math.ceil(total / limit),
  };
}
```

---

## ‚ö° CACHING STRATEGY (MANDATORY)

### **Next.js ISR (Server Components):**

Add to every Server Component page for automatic CDN caching:

```typescript
// Add at top of page.tsx (Server Component)
export const revalidate = 1800; // 30 minutes (adjust per page needs)

// Static data (locations, products, categories)
export const revalidate = 3600; // 60 minutes

// User data (worker profiles, teams)
export const revalidate = 1800; // 30 minutes

// Sales/Labor data (updated frequently)
export const revalidate = 300; // 5 minutes
```

### **React Query Stale Times (Client Components):**

```typescript
// Static data (locations, products)
staleTime: 60 * 60 * 1000, // 60 minutes

// User data (worker profiles)
staleTime: 30 * 60 * 1000, // 30 minutes

// Sales data (updated frequently)
staleTime: 5 * 60 * 1000, // 5 minutes

// Real-time data
staleTime: 1 * 60 * 1000, // 1 minute
```

**Current Problem:** Most ViewModels use 2-5 minute stale times, which is too short and causes unnecessary refetches.

---

## üéØ SERVER COMPONENT DECISION TREE

### **Use Server Component (NO "use client") when:**

- ‚úÖ Page fetches data from database/API
- ‚úÖ Data is needed for initial render
- ‚úÖ Page is mostly static/read-only
- ‚úÖ SEO matters
- ‚úÖ First paint performance critical

**Example:** Dashboard pages, data tables, reports

### **Use Client Component ("use client") when:**

- ‚úÖ Page has lots of interactivity (forms, modals, drag-drop)
- ‚úÖ Uses browser APIs (localStorage, geolocation)
- ‚úÖ Heavy state management throughout
- ‚úÖ Real-time updates (websockets)

**Example:** Settings pages, complex forms

### **Use Hybrid Pattern when:**

- ‚úÖ Data-heavy page with some interactivity (**MOST DASHBOARD PAGES**)
- ‚úÖ Need fast initial load + interactive UI
- ‚úÖ Want CDN caching + client-side updates

**Example:** Sales tables, worker lists, finance dashboards

---

## üîç MONGODB INDEX VERIFICATION

**Before deploying, verify all queries use indexes:**

```bash
# Check indexes exist
node -e "require('./src/lib/mongodb/v2-indexes').initializeDatabase()"

# View existing indexes
node -e "require('./src/lib/mongodb/v2-connection').getDatabase().then(db => db.collection('bork_aggregated').indexes().then(console.log))"
```

### **Index Rules:**

**Every `.find()` query MUST use indexed fields:**

```typescript
// ‚úÖ GOOD - Uses compound index (locationId + date)
db.collection('bork_aggregated').find({
  locationId: id,      // Indexed
  date: { $gte: start, $lte: end }  // Indexed
})

// ‚ùå BAD - Queries non-indexed field (SLOW!)
db.collection('bork_aggregated').find({
  productName: "Pizza"  // NOT indexed = full collection scan
})
```

**Current Indexes (from v2-indexes.ts):**

```typescript
bork_aggregated:
  - { locationId: 1, date: -1 } // Compound index
  - { date: -1 }

eitje_aggregated:
  - { locationId: 1, date: -1 } // Compound index
  - { date: -1 }

bork_raw_data:
  - { locationId: 1, date: -1 } // Compound index
  - { date: -1 }
  - { importId: 1 }
  - { createdAt: -1 }
```

---

## üìà PERFORMANCE TARGETS

### **First Paint:**
- ‚úÖ Target: < 1 second
- ‚ùå Current: 3-5 seconds (Client Components)
- ‚úÖ With SSR: 0.5-1 second

### **Data Fetch:**
- ‚úÖ Target: < 500ms
- ‚ùå Current: 2-4 seconds (no pagination)
- ‚úÖ With pagination: 300-800ms

### **Memory Usage:**
- ‚úÖ Target: < 100MB per page
- ‚ùå Current: ~500MB (fetches all data)
- ‚úÖ With pagination: ~50MB

---

## üö® COMMON PERFORMANCE MISTAKES

### **1. Fetching All Data (Most Common)**

```typescript
// ‚ùå BAD - Fetches 100k+ records
const allSales = await db.collection('bork_raw_data').find({}).toArray();

// ‚úÖ GOOD - Paginate at DB level
const sales = await db.collection('bork_raw_data')
  .find({})
  .skip((page - 1) * 50)
  .limit(50)
  .toArray();
```

### **2. Client-Side Pagination**

```typescript
// ‚ùå BAD - Fetches all, paginates in memory
const allData = await fetchAllData();
const page1 = allData.slice(0, 50);

// ‚úÖ GOOD - Database-level pagination
const page1 = await fetchData({ page: 1, limit: 50 });
```

### **3. N+1 Queries**

```typescript
// ‚ùå BAD - Makes 100 queries
for (const sale of sales) {
  const location = await db.collection('locations').findOne({ _id: sale.locationId });
}

// ‚úÖ GOOD - Single query with $in
const locationIds = sales.map(s => s.locationId);
const locations = await db.collection('locations').find({
  _id: { $in: locationIds }
}).toArray();
```

### **4. Short Stale Times**

```typescript
// ‚ùå BAD - Refetches every 2 minutes
staleTime: 2 * 60 * 1000,

// ‚úÖ GOOD - Cache for 30 minutes (data doesn't change often)
staleTime: 30 * 60 * 1000,
```

---

## ‚úÖ IMPLEMENTATION CHECKLIST

For every new page or optimization:

- [ ] Server Component wrapper (page.tsx without "use client")
- [ ] Client Component for UI (PageClient.tsx with "use client")
- [ ] ISR revalidation added (export const revalidate = 1800)
- [ ] ViewModel accepts initialData parameter
- [ ] Service can be called server-side (no browser APIs)
- [ ] Database queries use pagination (skip/limit)
- [ ] Database queries use indexed fields only
- [ ] React Query stale time >= 30 minutes for static data
- [ ] GraphQL resolver returns totalPages for pagination

---

**Performance is a FEATURE, not an afterthought!**
